<!DOCTYPE html>
<!-- saved from url=(0040)https://cs50.harvard.edu/x/2021/notes/5/ -->
<html lang="en-us" class="wf-ptsans-n7-active wf-ptsans-n4-active wf-active"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta property="og:description" content="Harvard University&#39;s introduction to the intellectual enterprises of computer science and the art of programming.">

        <meta property="og:image" content="https://img.youtube.com/vi/zYierUhIFNQ/maxresdefault.jpg"><meta property="og:title" content="Lecture 5 - CS50x 2021">

        <link href="https://cs50.harvard.edu/x/2021/favicon.ico?1630960824" rel="icon">

        <!-- https://fonts.google.com/specimen/PT+Sans?query=PT+Sans&selection.family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700 -->
        <script src="./Lecture 5 - CS50x 2021_files/webfont.js.download"></script>

        <!-- http://getbootstrap.com/docs/4.6/getting-started/introduction/ -->
        <script src="./Lecture 5 - CS50x 2021_files/jquery.min.js.download"></script>
        <script src="./Lecture 5 - CS50x 2021_files/bootstrap.bundle.min.js.download"></script>

        <!-- https://bootstrap-table.com/docs/getting-started/introduction/ -->
        <link href="./Lecture 5 - CS50x 2021_files/bootstrap-table.min.css" rel="stylesheet">
        <script src="./Lecture 5 - CS50x 2021_files/bootstrap-table.min.js.download"></script>
        <script src="./Lecture 5 - CS50x 2021_files/bootstrap-table-mobile.min.js.download"></script>

        <!-- https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use -->
        <link href="./Lecture 5 - CS50x 2021_files/all.min.css" rel="stylesheet">

        <!-- https://moment.github.io/luxon/ -->
        <script src="./Lecture 5 - CS50x 2021_files/luxon.min.js.download"></script>

        <!-- http://docs.mathjax.org/ -->
        <!-- https://www.jsdelivr.com/package/npm/mathjax?path=es5 -->
        <script crossorigin="anonymous" integrity="sha256-+nfSJ1LiSvANSK3wvi6FjM+oFwoIQvURU1frozp5z6o=" src="./Lecture 5 - CS50x 2021_files/tex-chtml.js.download"></script><style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style>

        <!-- https://github.com/verlok/vanilla-lazyload -->
        <script src="./Lecture 5 - CS50x 2021_files/intersection-observer.js.download"></script>
        <script src="./Lecture 5 - CS50x 2021_files/lazyload.min.js.download"></script>

        <!-- https://github.com/davidjbradshaw/iframe-resizer -->
        <!-- https://www.jsdelivr.com/package/npm/iframe-resizer?path=js -->
        <script crossorigin="anonymous" integrity="sha256-S8f0Q/V9VcfrqYgWo9EFS9zuDMdPTBMC+CBW0RjxQbs=" src="./Lecture 5 - CS50x 2021_files/iframeResizer.min.js.download"></script>

        <!-- https://github.com/scratchblocks/scratchblocks -->
        <script src="./Lecture 5 - CS50x 2021_files/scratchblocks-v3.5.2-min.js.download"></script><style><![CDATA[ .sb-label {
      font-family: Lucida Grande, Verdana, Arial, DejaVu Sans, sans-serif;
      font-weight: bold;
      fill: #fff;
      font-size: 10px;
      word-spacing: +1px;
    }

    .sb-obsolete { fill: #d42828; }
    .sb-motion { fill: #4a6cd4; }
    .sb-looks { fill: #8a55d7; }
    .sb-sound { fill: #bb42c3; }
    .sb-pen { fill: #0e9a6c;  }
    .sb-events { fill: #c88330; }
    .sb-control { fill: #e1a91a; }
    .sb-sensing { fill: #2ca5e2; }
    .sb-operators { fill: #5cb712; }
    .sb-variables { fill: #ee7d16; }
    .sb-list { fill: #cc5b22 }
    .sb-custom { fill: #632d99; }
    .sb-custom-arg { fill: #5947b1; }
    .sb-extension { fill: #4b4a60; }
    .sb-grey { fill: #969696; }

    .sb-bevel {
      filter: url(#bevelFilter);
    }

    .sb-input {
      filter: url(#inputBevelFilter);
    }
    .sb-input-number,
    .sb-input-string,
    .sb-input-number-dropdown {
      fill: #fff;
    }
    .sb-literal-number,
    .sb-literal-string,
    .sb-literal-number-dropdown,
    .sb-literal-dropdown {
      font-weight: normal;
      font-size: 9px;
      word-spacing: 0;
    }
    .sb-literal-number,
    .sb-literal-string,
    .sb-literal-number-dropdown {
      fill: #000;
    }

    .sb-darker {
      filter: url(#inputDarkFilter);
    }

    .sb-outline {
      stroke: #fff;
      stroke-opacity: 0.2;
      stroke-width: 2;
      fill: none;
    }

    .sb-define-hat-cap {
      stroke: #632d99;
      stroke-width: 1;
      fill: #8e2ec2;
    }

    .sb-comment {
      fill: #ffffa5;
      stroke: #d0d1d2;
      stroke-width: 1;
    }
    .sb-comment-line {
      fill: #ffff80;
    }
    .sb-comment-label {
      font-family: Helevetica, Arial, DejaVu Sans, sans-serif;
      font-weight: bold;
      fill: #5c5d5f;
      word-spacing: 0;
      font-size: 12px;
    }

    .sb-diff {
      fill: none;
      stroke: #000;
    }
    .sb-diff-ins {
      stroke-width: 2px;
    }
    .sb-diff-del {
      stroke-width: 3px;
    }
  ]]></style><style><![CDATA[ .sb3-label {
      font: 500 12pt Helevetica Neue, Helvetica, sans-serif;
      fill: #fff;
      word-spacing: +1pt;
    }

    .sb3-motion { fill: #4c97ff; stroke: #3373cc; }
    .sb3-motion-alt { fill: #4280d7; }
    .sb3-motion-dark { fill: #4c97ff; }
    .sb3-looks { fill: #9966ff; stroke: #774dcb; }
    .sb3-looks-alt { fill: #855cd6; }
    .sb3-looks-dark { fill: #bd42bd; }
    .sb3-sound { fill: #cf63cf; stroke: #bd42bd; }
    .sb3-sound-alt { fill: #c94fc9; }
    .sb3-sound-dark { fill: #bd42bd; }
    .sb3-control { fill: #ffab19; stroke: #cf8b17; }
    .sb3-control-alt { fill: #ec9c13; }
    .sb3-control-dark { fill: #cf8b17; }
    .sb3-events { fill: #ffbf00; stroke: #cc9900; }
    .sb3-events-alt { fill: #e6ac00; }
    .sb3-events-dark { fill: #cc9900; }
    .sb3-sensing { fill: #5cb1d6; stroke: #2e8eb8; }
    .sb3-sensing-alt { fill: #47a8d1; }
    .sb3-sensing-dark { fill: #2e8eb8; }
    .sb3-operators { fill: #59c059; stroke: #389438; }
    .sb3-operators-alt { fill: #46b946; }
    .sb3-operators-dark { fill: #389438; }
    .sb3-variables { fill: #ff8c1a; stroke: #db6e00; }
    .sb3-variables-alt { fill: #ff8000; }
    .sb3-variables-dark { fill: #db6e00; }
    .sb3-list { fill: #ff661a; stroke: #e64d00; }
    .sb3-list-alt { fill: #ff5500; }
    .sb3-list-dark { fill: #e64d00; }
    .sb3-custom { fill: #ff6680; stroke: #ff3355; }
    .sb3-custom-alt { fill: #ff4d6a; }
    .sb3-custom-dark { fill: #ff3355; }
    .sb3-custom-arg { fill: #ff6680; stroke: #ff3355; }

    /* extension blocks, e.g. pen */
    .sb3-extension { fill: #0fbd8c; stroke: #0b8e69; }
    .sb3-extension-alt { fill: #0da57a; }
    .sb3-extension-line { stroke: #0da57a; }
    .sb3-extension-dark { fill: #0b8e69; }

    /* obsolete colors: chosen by hand, indicates invalid blocks */
    .sb3-obsolete { fill: #ed4242; stroke: #ca2b2b; }
    .sb3-obsolete-alt { fill: #db3333; }
    .sb3-obsolete-dark { fill: #ca2b2b; }

    /* grey: special color from the Scratch 3.0 design mockups */
    .sb3-grey { fill: #bfbfbf; stroke: #909090; }
    .sb3-grey-alt { fill: #b2b2b2; }
    .sb3-grey-dark { fill: #909090; }

    .sb3-input-color {
      stroke: #fff;
    }

    .sb3-input-number,
    .sb3-input-string {
      fill: #fff;
    }
    .sb3-literal-number,
    .sb3-literal-string,
    .sb3-literal-number-dropdown,
    .sb3-literal-dropdown {
      word-spacing: 0;
    }
    .sb3-literal-number,
    .sb3-literal-string {
      fill: #575e75;
    }

    .sb3-comment {
      fill: #ffffa5;
      stroke: #d0d1d2;
      stroke-width: 1;
    }
    .sb3-comment-line {
      fill: #ffff80;
    }
    .sb3-comment-label {
      font: 400 12pt Helevetica Neue, Helvetica, sans-serif;
      fill: #000;
      word-spacing: 0;
    }

    .sb3-diff {
      fill: none;
      stroke: #000;
    }
    .sb3-diff-ins {
      stroke-width: 2px;
    }
    .sb3-diff-del {
      stroke-width: 3px;
    }
  ]]></style>

        

        <link href="./Lecture 5 - CS50x 2021_files/page.css" rel="stylesheet">
        <link rel="stylesheet" href="./Lecture 5 - CS50x 2021_files/css" media="all"><script src="./Lecture 5 - CS50x 2021_files/jekyll-theme-cs50.js.download"></script>

        <script>
            window.CS50 = {
                locale: "en",
                tz: "America/New_York"
            };
        </script>

        <title>Lecture 5 - CS50x 2021</title>


    <style id="MJX-CHTML-styles">
mjx-container[jax="CHTML"] {
  line-height: 0;
}

mjx-container [space="1"] {
  margin-left: .111em;
}

mjx-container [space="2"] {
  margin-left: .167em;
}

mjx-container [space="3"] {
  margin-left: .222em;
}

mjx-container [space="4"] {
  margin-left: .278em;
}

mjx-container [space="5"] {
  margin-left: .333em;
}

mjx-container [rspace="1"] {
  margin-right: .111em;
}

mjx-container [rspace="2"] {
  margin-right: .167em;
}

mjx-container [rspace="3"] {
  margin-right: .222em;
}

mjx-container [rspace="4"] {
  margin-right: .278em;
}

mjx-container [rspace="5"] {
  margin-right: .333em;
}

mjx-container [size="s"] {
  font-size: 70.7%;
}

mjx-container [size="ss"] {
  font-size: 50%;
}

mjx-container [size="Tn"] {
  font-size: 60%;
}

mjx-container [size="sm"] {
  font-size: 85%;
}

mjx-container [size="lg"] {
  font-size: 120%;
}

mjx-container [size="Lg"] {
  font-size: 144%;
}

mjx-container [size="LG"] {
  font-size: 173%;
}

mjx-container [size="hg"] {
  font-size: 207%;
}

mjx-container [size="HG"] {
  font-size: 249%;
}

mjx-container [width="full"] {
  width: 100%;
}

mjx-box {
  display: inline-block;
}

mjx-block {
  display: block;
}

mjx-itable {
  display: inline-table;
}

mjx-row {
  display: table-row;
}

mjx-row > * {
  display: table-cell;
}

mjx-mtext {
  display: inline-block;
}

mjx-mstyle {
  display: inline-block;
}

mjx-merror {
  display: inline-block;
  color: red;
  background-color: yellow;
}

mjx-mphantom {
  visibility: hidden;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-c::before {
  display: block;
  width: 0;
}

.MJX-TEX {
  font-family: MJXZERO, MJXTEX;
}

.TEX-B {
  font-family: MJXZERO, MJXTEX-B;
}

.TEX-I {
  font-family: MJXZERO, MJXTEX-I;
}

.TEX-MI {
  font-family: MJXZERO, MJXTEX-MI;
}

.TEX-BI {
  font-family: MJXZERO, MJXTEX-BI;
}

.TEX-S1 {
  font-family: MJXZERO, MJXTEX-S1;
}

.TEX-S2 {
  font-family: MJXZERO, MJXTEX-S2;
}

.TEX-S3 {
  font-family: MJXZERO, MJXTEX-S3;
}

.TEX-S4 {
  font-family: MJXZERO, MJXTEX-S4;
}

.TEX-A {
  font-family: MJXZERO, MJXTEX-A;
}

.TEX-C {
  font-family: MJXZERO, MJXTEX-C;
}

.TEX-CB {
  font-family: MJXZERO, MJXTEX-CB;
}

.TEX-FR {
  font-family: MJXZERO, MJXTEX-FR;
}

.TEX-FRB {
  font-family: MJXZERO, MJXTEX-FRB;
}

.TEX-SS {
  font-family: MJXZERO, MJXTEX-SS;
}

.TEX-SSB {
  font-family: MJXZERO, MJXTEX-SSB;
}

.TEX-SSI {
  font-family: MJXZERO, MJXTEX-SSI;
}

.TEX-SC {
  font-family: MJXZERO, MJXTEX-SC;
}

.TEX-T {
  font-family: MJXZERO, MJXTEX-T;
}

.TEX-V {
  font-family: MJXZERO, MJXTEX-V;
}

.TEX-VB {
  font-family: MJXZERO, MJXTEX-VB;
}

mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c {
  font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A ! important;
}

@font-face /* 0 */ {
  font-family: MJXZERO;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff");
}

@font-face /* 1 */ {
  font-family: MJXTEX;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff");
}

@font-face /* 2 */ {
  font-family: MJXTEX-B;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff");
}

@font-face /* 3 */ {
  font-family: MJXTEX-I;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff");
}

@font-face /* 4 */ {
  font-family: MJXTEX-MI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff");
}

@font-face /* 5 */ {
  font-family: MJXTEX-BI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff");
}

@font-face /* 6 */ {
  font-family: MJXTEX-S1;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff");
}

@font-face /* 7 */ {
  font-family: MJXTEX-S2;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff");
}

@font-face /* 8 */ {
  font-family: MJXTEX-S3;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff");
}

@font-face /* 9 */ {
  font-family: MJXTEX-S4;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff");
}

@font-face /* 10 */ {
  font-family: MJXTEX-A;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff");
}

@font-face /* 11 */ {
  font-family: MJXTEX-C;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff");
}

@font-face /* 12 */ {
  font-family: MJXTEX-CB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff");
}

@font-face /* 13 */ {
  font-family: MJXTEX-FR;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff");
}

@font-face /* 14 */ {
  font-family: MJXTEX-FRB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff");
}

@font-face /* 15 */ {
  font-family: MJXTEX-SS;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff");
}

@font-face /* 16 */ {
  font-family: MJXTEX-SSB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff");
}

@font-face /* 17 */ {
  font-family: MJXTEX-SSI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff");
}

@font-face /* 18 */ {
  font-family: MJXTEX-SC;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff");
}

@font-face /* 19 */ {
  font-family: MJXTEX-T;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff");
}

@font-face /* 20 */ {
  font-family: MJXTEX-V;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff");
}

@font-face /* 21 */ {
  font-family: MJXTEX-VB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff");
}
</style></head>

    <body class="" cz-shortcut-listen="true">

        <div class="alert fixed-top mb-0 rounded-0 shadow alert-success alert-dismissible" data-alert="success dismissible" data-hash="14c26b7088b495629d13e2eb6186501b" id="alert" role="alert">
            <button aria-label="Close" class="btn-close" data-bs-dismiss="alert" type="button"></button><p>Interested in <a href="https://cs50.harvard.edu/x/2021/#how-to-take-this-course" class="alert-link">a verified certificate, a professional certificate, or transfer credit and accreditation</a>?
And get vaccinated (as soon as it’s available to you). 💉 <a href="https://www.who.int/news-room/q-a-detail/coronavirus-disease-(covid-19)-vaccines" class="alert-link">Here’s why</a>. <a href="https://www.google.com/search?q=covid-19+vaccine+finder" class="alert-link">Here’s how</a>.</p></div>
        

        <div class="container-fluid">

            <div class="row">

                <aside class="col-md" style="height: 638px; top: 58px;">
 
                    <header><h1 data-id="this-is-cs50x"><a href="https://cs50.harvard.edu/x/2021/">This is CS50x</a></h1>

<p>OpenCourseWare</p>

<p><a class="pr-1 small" href="https://cs50.harvard.edu/donate">Donate<i aria-hidden="true" class="fas fa-external-link-alt ps-2"></i></a></p>

<p><a href="https://cs.harvard.edu/malan/">David J. Malan</a>
<br>
<a href="mailto:malan@harvard.edu">malan@harvard.edu</a>
<br>
<a class="mr-1" href="https://www.facebook.com/dmalan"><i aria-hidden="true" class="fab fa-facebook-f" title="Facebook"></i><span class="sr-only">Facebook</span></a>
<a class="mr-1" href="https://github.com/dmalan"><i aria-hidden="true" class="fab fa-github" title="GitHub"></i><span class="sr-only">GitHub</span></a>
<a class="mr-1" href="https://www.instagram.com/davidjmalan/"><i aria-hidden="true" class="fab fa-instagram" title="Instagram"></i><span class="sr-only">Instagram</span></a>
<a class="mr-1" href="https://www.linkedin.com/in/malan/"><i aria-hidden="true" class="fab fa-linkedin" title="LinkedIn"></i><span class="sr-only">LinkedIn</span></a>
<a class="mr-1" href="https://orcid.org/0000-0001-5338-2522"><i aria-hidden="true" class="fab fa-orcid" title="ORCID"></i><span class="sr-only">ORCID</span></a>
<a class="mr-1" href="https://www.quora.com/profile/David-J-Malan"><i aria-hidden="true" class="fab fa-quora" title="Quora"></i><span class="sr-only">Quora</span></a>
<a class="mr-1" href="https://www.reddit.com/user/davidjmalan"><i aria-hidden="true" class="fab fa-reddit-alien" title="Reddit"></i><span class="sr-only">Reddit</span></a>
<a class="mr-1" href="https://twitter.com/davidjmalan"><i aria-hidden="true" class="fab fa-twitter" title="Twitter"></i><span class="sr-only">Twitter</span></a></p></header>

                    

                    <button aria-controls="nav" aria-expanded="false" class="btn btn-sm collapsed d-md-none" data-bs-target="aside &gt; nav" data-bs-toggle="collapse">
                        Menu
                    </button>

                    <nav class="collapse d-md-block" id="nav"><hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.ly/zoom/"><i class="fas fa-video pe-2"></i>Zoom Meetings</a></li>
</ul>

<hr>

<ul class="small fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/workshop/">CS50 Educator Workshop 2021</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/seminars/">CS50’s New Year’s Seminars<span aria-hidden="true" class="ps-2 text-decoration-none">🥂</span></a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/gallery/">Gallery of Final Projects<span aria-hidden="true" class="ps-2 text-decoration-none">🖼️ </span></a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/new/">What’s new for 2021?</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/0/">Week 0</a> Scratch</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/1/">Week 1</a> C</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/2/">Week 2</a> Arrays</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/3/">Week 3</a> Algorithms</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/4/">Week 4</a> Memory</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/5/">Week 5</a> Data Structures</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/6/">Week 6</a> Python</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/7/">Week 7</a> SQL</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/8/">Week 8</a> HTML, CSS, JavaScript</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/9/">Week 9</a> Flask</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/10/">Week 10</a> Ethics</li>
</ul>
<ul class="fa-ul">
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/security/">Security</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/weeks/ai/">Artificial Intelligence</a></li>
</ul>
<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/project/">Final Project</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/honesty/">Academic Honesty</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/certificate/">CS50 Certificate</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/faqs/">FAQs</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.me/cs50x">Gradebook</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/staff/">Staff</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/syllabus/">Syllabus</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.edx.org/ed">Ed Discussion</a> for Q&amp;A</li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://us.edstem.org/quickstart/ed-discussion.pdf">Quick Start Guide</a></li>
</ul>

<hr>

<ul class="small fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.edx.org/">edX</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.youtube.com/playlist?list=PLhQjrBD2T382_R182iC2gNZI9HzWFMC_8">YouTube</a></li>
</ul>

<hr>

<ul class="small fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://ide.cs50.io/">CS50 IDE</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.w3schools.com/css/">CSS Tutorial</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://flask.palletsprojects.com/en/1.1.x/quickstart/">Flask Quickstart</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.w3schools.com/html/">HTML Tutorial</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://jinja.palletsprojects.com/en/2.11.x/templates/">Jinja Template Designer Documentation</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://man.cs50.io/">Manual Pages</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://docs.python.org/3.7/search.html">Python Documentation</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://scratch.mit.edu/">Scratch</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.w3schools.com/sql/">SQL Tutorial</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.readthedocs.io/style/c/">Style Guide</a></li>
</ul>

<hr>

<ul class="small fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.noticeable.news/">Changelog</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.statuspage.io/">Status Page</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/x/2021/communities/"><strong>Communities</strong></a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.clubhouse.com/club/cs50">Clubhouse</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://discord.gg/cs50">Discord</a> <span class="badge bg-light ms-1 py-1 rounded-pill text-dark">Q&amp;A</span></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.edx.org/ed">Ed</a> <span class="badge bg-light ms-1 py-1 rounded-pill text-dark">Q&amp;A</span></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.facebook.com/groups/cs50/">Facebook Group</a> <span class="badge bg-light ms-1 py-1 rounded-pill text-dark">Q&amp;A</span></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.facebook.com/cs50/">Facebook Page</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://github.com/cs50">GitHub</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://gitter.im/cs50/x">Gitter</a> <span class="badge bg-light ms-1 py-1 rounded-pill text-dark">Q&amp;A</span></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://instagram.com/cs50">Instagram</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.linkedin.com/groups/7437240/">LinkedIn Group</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.linkedin.com/school/CS50/">LinkedIn Page</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.medium.com/">Medium</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.quora.com/topic/CS50">Quora</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.reddit.com/r/cs50/">Reddit</a> <span class="badge bg-light ms-1 py-1 rounded-pill text-dark">Q&amp;A</span></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.edx.org/slack">Slack</a> <span class="badge bg-light ms-1 py-1 rounded-pill text-dark">Q&amp;A</span></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://www.snapchat.com/add/cs50">Snapchat</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://soundcloud.com/cs50">SoundCloud</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.stackexchange.com/">Stack Exchange</a> <span class="badge bg-light ms-1 py-1 rounded-pill text-dark">Q&amp;A</span></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://twitter.com/cs50">Twitter</a></li>
  <li data-marker="*" class="small"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="http://www.youtube.com/subscription_center?add_user=cs50tv">YouTube</a></li>
</ul>

<hr>

<p><a href="https://cs50.harvardshop.com/"><img src="./Lecture 5 - CS50x 2021_files/GGMdcKt.png" alt="Harvard Shop"></a></p>

<hr>

<p><a href="https://cs50.harvard.edu/x/2021/license/" class="small"><i class="fab fa-creative-commons me-1"></i>License</a></p></nav>

                    <footer></footer>

                </aside>

                <main class="col-md" style="margin-bottom: 0px; margin-top: 58px;">

                    <a data-id="" id="lecture-5" style="top: -58px;"></a><h1 class="no_toc"><a data-id="" href="https://cs50.harvard.edu/x/2021/notes/5/#lecture-5">Lecture 5</a></h1>

<ul id="markdown-toc">
  <li><a href="https://cs50.harvard.edu/x/2021/notes/5/#resizing-arrays" id="markdown-toc-resizing-arrays">Resizing arrays</a></li>
  <li><a href="https://cs50.harvard.edu/x/2021/notes/5/#data-structures" id="markdown-toc-data-structures">Data structures</a></li>
  <li><a href="https://cs50.harvard.edu/x/2021/notes/5/#linked-lists" id="markdown-toc-linked-lists">Linked Lists</a></li>
  <li><a href="https://cs50.harvard.edu/x/2021/notes/5/#implementing-arrays" id="markdown-toc-implementing-arrays">Implementing arrays</a></li>
  <li><a href="https://cs50.harvard.edu/x/2021/notes/5/#implementing-linked-lists" id="markdown-toc-implementing-linked-lists">Implementing linked lists</a></li>
  <li><a href="https://cs50.harvard.edu/x/2021/notes/5/#trees" id="markdown-toc-trees">Trees</a></li>
  <li><a href="https://cs50.harvard.edu/x/2021/notes/5/#more-data-structures" id="markdown-toc-more-data-structures">More data structures</a></li>
</ul>

<a data-id="" id="resizing-arrays" style="top: -58px;"></a><h2><a data-id="" href="https://cs50.harvard.edu/x/2021/notes/5/#resizing-arrays">Resizing arrays</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Last time, we learned about pointers, <code class="language-plaintext highlighter-rouge">malloc</code>, and other useful tools for working with memory.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>In week 2, we learned about arrays, where we could store the same kind of value in a list, back-to-back in memory. When we need to insert an element, we need to increase the size of the array as well. But, the memory after it in our computer might already be used for some other data, like a string:<br>
<img src="./Lecture 5 - CS50x 2021_files/array_of_length_3.png" alt="boxes of garbage values, with boxes for values 1, 2, 3, and a string after in gray"></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>One solution might be to allocate more memory where there’s enough space, and move our array there. But we’ll need to copy our array there, which becomes an operation with running time of <em>O</em>(<em>n</em>), since we need to copy each of the original <em>n</em> elements first:<br>
<img src="./Lecture 5 - CS50x 2021_files/array_of_length_4.png" alt="boxes of original array with values 1, 2, 3 and a new array with copied values 1, 2, 3, and space for new value">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>The lower bound of inserting an element into an array would be O(1) since we might already have space in the array for it.</li>
    </ul>
  </li>
</ul>

<a data-id="" id="data-structures" style="top: -58px;"></a><h2><a data-id="" href="https://cs50.harvard.edu/x/2021/notes/5/#data-structures">Data structures</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><strong>Data structures</strong> are more complex ways to organize data in memory, allowing us to store information in different layouts.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>To build a data structure, we’ll need some tools:
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><code class="language-plaintext highlighter-rouge">struct</code> to create custom data types</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><code class="language-plaintext highlighter-rouge">.</code> to access properties in a structure</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><code class="language-plaintext highlighter-rouge">*</code> to go to an address in memory pointed to by a pointer</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><code class="language-plaintext highlighter-rouge">-&gt;</code> to access properties in a structure pointed to by a pointer</li>
    </ul>
  </li>
</ul>

<a data-id="" id="linked-lists" style="top: -58px;"></a><h2><a data-id="" href="https://cs50.harvard.edu/x/2021/notes/5/#linked-lists">Linked Lists</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>With a <strong>linked list</strong>, we can store a list of values that can easily be grown by storing values in different parts of memory:<br>
<img src="./Lecture 5 - CS50x 2021_files/linked_list.png" alt="grid representing memory, with three of the boxes labeled with empty boxes between them, each labeled 1 0x123, 2 0x456, and 3 0x789">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We have the values <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, and <code class="language-plaintext highlighter-rouge">3</code>, each at some address in memory like <code class="language-plaintext highlighter-rouge">0x123</code>, <code class="language-plaintext highlighter-rouge">0x456</code>, and <code class="language-plaintext highlighter-rouge">0x789</code>.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>This is different than an array since our values are no longer next to one another in memory. We can use whatever locations in memory that are free.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>To track all of these values, we need link our list together by allocating, for each element, enough memory for both the value we want to store, and the address of the next element:<br>
<img src="./Lecture 5 - CS50x 2021_files/linked_list_with_addresses.png" alt="three boxes, each divided in two and labeled (1 0x123 and 0x456), (2 0x456 and 0x789), and (3 0x789 and NULL)">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Next to our value of <code class="language-plaintext highlighter-rouge">1</code>, for example, we also store a pointer, <code class="language-plaintext highlighter-rouge">0x456</code>, to the next value. We’ll call this a <strong>node</strong>, a component of our data structure that stores both a value and a pointer. In C, we’ll implement our nodes with a struct.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>For our last node with value <code class="language-plaintext highlighter-rouge">3</code>, we have the null pointer, since there’s no next element. When we need to insert another node, we can just change that single null pointer to point to our new value.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We have the tradeoff of needing to allocate twice as much memory for each element, in order to spend less time adding values. And we can no longer use binary search, since our nodes might be anywhere in memory. We can only access them by following the pointers, one at a time.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>In code, we might create our own struct called <code class="language-plaintext highlighter-rouge">node</code>, and we need to store both our value, an <code class="language-plaintext highlighter-rouge">int</code> called <code class="language-plaintext highlighter-rouge">number</code>, and a pointer to the next <code class="language-plaintext highlighter-rouge">node</code>, called <code class="language-plaintext highlighter-rouge">next</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">node</span><span class="p">;</span>
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We start this struct with <code class="language-plaintext highlighter-rouge">typedef struct node</code> so that we can refer to a <code class="language-plaintext highlighter-rouge">node</code> inside our struct.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can build a linked list in code starting with our struct. First, we’ll want to remember an empty list, so we can use the null pointer: <code class="language-plaintext highlighter-rouge">node *list = NULL;</code>.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>To add an element, first we’ll need to allocate some memory for a node, and set its values:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We use sizeof(node) to get the right amount of memory to allocate, and</span>
<span class="c1">// malloc returns a pointer that we save as n</span>
<span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>

<span class="c1">// We want to make sure malloc succeeded in getting memory for us</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// This is equivalent to (*n).number, where we first go to the node pointed</span>
    <span class="c1">// to by n, and then set the number property. In C, we can also use this</span>
    <span class="c1">// arrow notation</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// Then we need to make sure the pointer to the next node in our list</span>
    <span class="c1">// isn't a garbage value, but the new node won't point to anything (for now)</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now our list needs to point to this node: <code class="language-plaintext highlighter-rouge">list = n;</code>:<br>
<img src="./Lecture 5 - CS50x 2021_files/list_with_one_node.png" alt="a box labeled list with arrow outwards pointing to two connected boxes, one with 1 and one empty)"></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>To add to the list, we’ll create a new node the same way by allocating more memory:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>But now we need to update the pointer in our first node to point to our new <code class="language-plaintext highlighter-rouge">n</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>To add a third node, we’ll do the same by following the <code class="language-plaintext highlighter-rouge">next</code> pointer in our list first, then setting the <code class="language-plaintext highlighter-rouge">next</code> pointer <em>there</em> to point to the new node:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Graphically, our nodes in memory look like this:<br>
<img src="./Lecture 5 - CS50x 2021_files/list_with_three_nodes.png" alt="a box labeled list with arrow pointing to node with 1 and arrow pointing to another node with 2 and arrow pointing to third node with 3 and no pointer, and box labeled n pointing to third node`">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><code class="language-plaintext highlighter-rouge">n</code> is a temporary variable, pointing to our new node with value 3.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We want the pointer in our node with value 2 to point to the new node as well, so we start from <code class="language-plaintext highlighter-rouge">list</code> (which points to the node with value 1), follow the <code class="language-plaintext highlighter-rouge">next</code> pointer to get to our node with value 2, and update the <code class="language-plaintext highlighter-rouge">next</code> pointer to point to <code class="language-plaintext highlighter-rouge">n</code>.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>As a result, searching a linked list will also have running time of O(<em>n</em>), since we need to look at all elements in order by following each pointer, even if the list is sorted. Inserting into a linked list can have running time of O(1), if we insert new nodes at the beginning of the list.</li>
</ul>

<a data-id="" id="implementing-arrays" style="top: -58px;"></a><h2><a data-id="" href="https://cs50.harvard.edu/x/2021/notes/5/#implementing-arrays">Implementing arrays</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Let’s see how we might implement resizing an array:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Use malloc to allocate enough space for an array with 3 integers</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Set the values in our array</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// Now if we want to store another value, we can allocate more memory</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Copy list of size 3 into list of size 4</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// Add new number to list of size 4</span>
    <span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="c1">// Free original list of size 3</span>
    <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

    <span class="c1">// Remember new list of size 4</span>
    <span class="n">list</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

    <span class="c1">// Print list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">// Free new list</span>
    <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Recall that <code class="language-plaintext highlighter-rouge">malloc</code> allocates and frees memory from the heap area. It turns out that we can call another library function, <code class="language-plaintext highlighter-rouge">realloc</code>, to reallocate some memory that we allocated earlier:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And <code class="language-plaintext highlighter-rouge">realloc</code> copies our old array, <code class="language-plaintext highlighter-rouge">list</code>, for us into a bigger chunk of memory of the size we pass in. If there happens to be space after our existing chunk of memory, we’ll get the same address back, but with the memory after it allocated to our variable as well.</li>
    </ul>
  </li>
</ul>

<a data-id="" id="implementing-linked-lists" style="top: -58px;"></a><h2><a data-id="" href="https://cs50.harvard.edu/x/2021/notes/5/#implementing-linked-lists">Implementing linked lists</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Let’s combine our snippets of code from earlier into a program that implements a linked list:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="c1">// Represents a node</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">node</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// List of size 0. We initialize the value to NULL explicitly, so there's</span>
    <span class="c1">// no garbage value for our list variable</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Allocate memory for a node, n</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Set the value and pointer in our node</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Add node n by pointing list to it, since we only have one node so far</span>
    <span class="n">list</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="c1">// Allocate memory for another node, and we can reuse our variable n to</span>
    <span class="c1">// point to it, since list points to the first node already</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Set the values in our new node</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Update the pointer in our first node to point to the second node</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="c1">// Allocate memory for a third node</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Free both of our other nodes</span>
        <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Follow the next pointer of the list to the second node, and update</span>
    <span class="c1">// the next pointer there to point to n</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="c1">// Print list using a loop, by using a temporary variable, tmp, to point</span>
    <span class="c1">// to list, the first node. Then, every time we go over the loop, we use</span>
    <span class="c1">// tmp = tmp-&gt;next to update our temporary pointer to the next node. We</span>
    <span class="c1">// keep going as long as tmp points to somewhere, stopping when we get to</span>
    <span class="c1">// the last node and tmp-&gt;next is null.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Free list, by using a while loop and a temporary variable to point</span>
    <span class="c1">// to the next node before freeing the current one</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">list</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// We point to the next node first</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="c1">// Then, we can free the first node</span>
        <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="c1">// Now we can set the list to point to the next node</span>
        <span class="n">list</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="c1">// If list is null, when there are no nodes left, our while loop will stop</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>If we want to insert a node to the front of our linked list, we would need to carefully update our node to point to the one following it, before updating the list variable. Otherwise, we’ll lose the rest of our list:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Here, we're inserting a node into the front of the list, so we want its</span>
<span class="c1">// next pointer to point to the original list. Then we can change the list to</span>
<span class="c1">// point to n.</span>
<span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
<span class="n">list</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>At first, we’ll have a node with value <code class="language-plaintext highlighter-rouge">1</code> pointing to the start of our list, a node with value <code class="language-plaintext highlighter-rouge">2</code>:<br>
<img src="./Lecture 5 - CS50x 2021_files/inserting_linked_list.png" alt="boxes labeled list and 1 pointing to a box labeled 2, pointing at a box labeled 4, pointing at a box labeled 5">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now we can update our <code class="language-plaintext highlighter-rouge">list</code> variable to point to the node with value <code class="language-plaintext highlighter-rouge">1</code>, and not lose the rest of our list.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Similarly, to insert a node in the middle of our list, we change the <code class="language-plaintext highlighter-rouge">next</code> pointer of the new node first to point to the rest of the list, then update the previous node to point to the new node.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>A linked list demonstrates how we can use pointers to build flexible data structures in memory, though we’re only visualizing it in one dimension.</li>
</ul>

<a data-id="" id="trees" style="top: -58px;"></a><h2><a data-id="" href="https://cs50.harvard.edu/x/2021/notes/5/#trees">Trees</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>With a sorted array, we can use binary search to find an element, starting at the middle (yellow), then the middle of either half (red), and finally left or right (green) as needed:<br>
<img src="./Lecture 5 - CS50x 2021_files/sorted_array.png" alt="boxes labeled 1, green; 2, red; 3, green; 4, yellow; 5, green; 6, red; 7, green">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>With an array, we can randomly access elements in O(1) time, since we can use arithmetic to go to an element at any index.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>A <strong>tree</strong> is another data structure where each node points to two other nodes, one to the left (with a smaller value) and one to the right (with a larger value):<br>
<img src="./Lecture 5 - CS50x 2021_files/tree.png" alt="tree with node 4 at top center, left arrow to 3 below, right arrow to 6 below; 2 has left arrow to 1 below, right arrow to 3 below; 6 has left arrow to 5 below, right arrow to 7 below">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Notice that we now visualize this data structure in two dimensions (even though the nodes in memory can be at any location).</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And we can implement this with a more complex version of a node in a linked list, where each node has not one but two pointers to other nodes. All the values to the left of a node are smaller, and all the values of nodes to the right are greater, which allows this to be used as a <strong>binary search tree</strong>. And the data structure is itself defined recursively, so we can use recursive functions to work with it.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Each node has at most two <strong>children</strong>, or nodes it is pointing to.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And like a linked list, we’ll want to keep a pointer to just the beginning of the list, but in this case we want to point to the <strong>root</strong>, or top center node of the tree (the 4).</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can define a node with not one but two pointers:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">node</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And write a function to recursively search a tree:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// tree is a pointer to a node that is the root of the tree we're searching in.</span>
<span class="c1">// number is the value we're trying to find in the tree.</span>
<span class="n">bool</span> <span class="nf">search</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// First, we make sure that the tree isn't NULL, if we've reached a node</span>
    <span class="c1">// on the bottom, or if our tree is entirely empty</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// If we're looking for a number that's less than the tree's number,</span>
    <span class="c1">// search the left side, using the node on the left as the new root</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Otherwise, search the right side, using the node on the right as the new root</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Finally, we've found the number we're looking for, so we can return true.</span>
    <span class="c1">// We can simplify this to just "else", since there's no other case possible</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>With a binary search tree, we’ve incurred the cost of even more memory, since each node now needs space for a value and two pointers. Inserting a new value would take O(log <em>n</em>) time, since we need to find the nodes that it should go between.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>If we add enough nodes, though, our search tree might start to look like a linked list:<br>
<img src="./Lecture 5 - CS50x 2021_files/imbalanced_tree.png" alt="node with 1 pointing at node with 2 pointing at node with 3">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We started our tree with a node with value of <code class="language-plaintext highlighter-rouge">1</code>, then added the node with value <code class="language-plaintext highlighter-rouge">2</code>, and finally added the node with value <code class="language-plaintext highlighter-rouge">3</code>. Even though this tree follows the constraints of a binary search tree, it’s not as efficient as it could be.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can make the tree balanced, or optimal, by making the node with value <code class="language-plaintext highlighter-rouge">2</code> the new root node. More advanced courses will cover data structures and algorithms that help us keep trees balanced as nodes are added.</li>
    </ul>
  </li>
</ul>

<a data-id="" id="more-data-structures" style="top: -58px;"></a><h2><a data-id="" href="https://cs50.harvard.edu/x/2021/notes/5/#more-data-structures">More data structures</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>A data structure with almost a constant time, O(1) search is a <strong>hash table</strong>, which is essentially an array <em>of</em> linked lists. Each linked list in the array has elements of a certain category.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>For example, we might have lots of names, and we might sort them into an array with 26 positions, one for each letter of the alphabet:<br>
<img src="./Lecture 5 - CS50x 2021_files/hash_table.png" alt="vertical array with 26 boxes, the first with an arrow pointing to a box labeled Albus, the second empty, the third with an arrow pointing to a box labeled Cedric ... the eighth with an arrow pointing to a box labeled Hermione with an arrow from that box pointing to a box labeled Harry with an arrow to a box labeled Hagrid ...">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Since we have random access with arrays, we can set elements and index into a location, or bucket, in the array quickly.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>A location might have multiple matching values, but we can add a value to another value since they’re nodes in a linked list, as we see with Hermione, Harry, and Hagrid. We don’t need to grow the size of our array or move any of our other values.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>This is called a hash table because we use a <strong>hash function</strong>, which takes some input and deterministically maps it to the location it should go in. In our example, the hash function just returns an index corresponding to the first letter of the name, such as <code class="language-plaintext highlighter-rouge">0</code> for “Albus” and <code class="language-plaintext highlighter-rouge">25</code> for “Zacharias”.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>But in the worst case, all the names might start with the same letter, so we might end up with the equivalent of a single linked list again. We might look at the first two letters, and allocate enough buckets for 26*26 possible hashed values, or even the first three letters, requiring 26*26*26 buckets:<br>
<img src="./Lecture 5 - CS50x 2021_files/hash_table_three_letters.png" alt="vertical array with boxes labeled ... Haa, Hab, Hac ... Har ... Her ...">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now, we’re using more space in memory, since some of those buckets will be empty, but we’re more likely to only need one step to look for a value, reducing our running time for search.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>To sort some standard playing cards, too, we might first start with putting them in piles by suit, of spades, diamonds, hearts, and clubs. Then, we can sort each pile a little more quickly.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>It turns out that the worst case running time for a hash table is O(<em>n</em>), since, as <em>n</em> gets very large, each bucket will have on the order of <em>n</em> values, even if we have hundreds or thousands of buckets. In practice, though, our running time will be faster since we’re dividing our values into multiple buckets.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>In problem set 5, we’ll be challenged to improve the real world running time of searching for values in our data structures, while also balancing our use of memory.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can use another data structure called a <strong>trie</strong> (pronounced like “try”, and is short for “retrieval”). A trie is a tree with arrays as nodes:<br>
<img src="./Lecture 5 - CS50x 2021_files/trie.png" alt="array with letters from A-Z in 26 elements, with H pointing to another array with all 26 letters. this array&#39;s A and E each point to two more arrays of all 26 letters, and this continues in a tree until the bottom-most arrays have only one letter marked as valid">
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Each array will have each letter, A-Z, stored. For each word, the first letter will point to an array, where the next valid letter will point to another array, and so on, until we reach a boolean value indicating the end of a valid word, marked in green above. If our word isn’t in the trie, then one of the arrays won’t have a pointer or terminating character for our word.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>In the trie above, we have the words Hagrid, Harry, and Hermione.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now, even if our data structure has lots of words, the maximum lookup time will be just the length of the word we’re looking for. This might be a fixed maximum, so we can have <em>O</em>(1) for searching and insertion.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>The cost for this, though, is that we need lots of memory to store pointers and boolean values as indicators of valid words, even though lots of them won’t be used.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>There are even higher-level constructs, <strong>abstract data structures</strong>, where we use our building blocks of arrays, linked lists, hash tables, and tries to <em>implement</em> a solution to some problem.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>For example, one abstract data structure is a <strong>queue</strong>, like a line of people waiting, where the first value we put in are the first values that are removed, or first-in-first-out (FIFO). To add a value we <strong>enqueue</strong> it, and to remove a value we <strong>dequeue</strong> it. This data structure is abstract because it’s an idea that we can implement in different ways: with an array that we resize as we add and remove items, or with a linked list where we append values to the end.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>An “opposite” data structure would be a <strong>stack</strong>, where items most recently added are removed first: last-in-first-out (LIFO). At a clothing store, we might take, or <strong>pop</strong>, the top sweater from a stack, and new sweaters would be added, or <strong>pushed</strong>, to the top as well.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Another example of an abstract data structure is a <strong>dictionary</strong>, where we can map keys to values, such as words to their definitions. We can implement one with a hash table or an array, taking into account the tradeoff between time and space.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We take a look at <a href="https://www.youtube.com/watch?v=ItAG3s6KIEI">“Jack Learns the Facts About Queues and Stacks”</a>, an animation about these data structures.</li>
</ul>


                </main>

            </div>

        </div>

        
 
        <script src="./Lecture 5 - CS50x 2021_files/page.js.download"></script>

    


</body></html>